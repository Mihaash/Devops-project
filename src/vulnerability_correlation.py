from typing import Dict, List, Any, Tuple
import re
from datetime import datetime
import logging

class VulnerabilityCorrelation:
    """Correlates vulnerabilities with company assets"""
    
    def __init__(self, assets: Dict[str, Any]):
        self.assets = assets
        self.logger = logging.getLogger(__name__)
        
    def correlate_cves_with_assets(self, cves: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Correlate CVEs with company assets"""
        correlated_vulnerabilities = []
        
        try:
            for cve in cves:
                affected_assets = self._find_affected_assets(cve)
                
                if affected_assets:
                    for asset in affected_assets:
                        vulnerability = {
                            "cve_id": cve["id"],
                            "description": cve["description"],
                            "severity": cve["severity"],
                            "cvss_score": cve["cvss_score"],
                            "published_date": cve["published_date"],
                            "affected_asset": asset["name"],
                            "asset_type": asset["type"],
                            "asset_ip": asset.get("ip", "N/A"),
                            "affected_software": cve["affected_software"],
                            "remediation_priority": self._calculate_remediation_priority(cve, asset)
                        }
                        correlated_vulnerabilities.append(vulnerability)
            
            self.logger.info(f"Correlated {len(correlated_vulnerabilities)} vulnerabilities with assets")
            
        except Exception as e:
            self.logger.error(f"Error correlating CVEs with assets: {e}")
            
        return correlated_vulnerabilities
    
    def correlate_malware_with_assets(self, malware_indicators: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Correlate malware indicators with company assets"""
        correlated_threats = []
        
        try:
            for indicator in malware_indicators:
                # Check if malicious IP matches any company asset IPs
                if indicator["type"] == "malicious_ip":
                    matching_assets = self._find_assets_by_ip(indicator["value"])
                    
                    for asset in matching_assets:
                        threat = {
                            "indicator_type": indicator["type"],
                            "indicator_value": indicator["value"],
                            "malware_family": indicator["malware_family"],
                            "confidence": indicator["confidence"],
                            "first_seen": indicator["first_seen"],
                            "affected_asset": asset["name"],
                            "asset_type": asset["type"],
                            "asset_ip": asset.get("ip", "N/A"),
                            "description": indicator["description"],
                            "severity": self._calculate_malware_severity(indicator, asset)
                        }
                        correlated_threats.append(threat)
                
                # For other indicator types, we can add more correlation logic
                elif indicator["type"] in ["malicious_domain", "malicious_hash"]:
                    # Create general threat alerts for these indicators
                    threat = {
                        "indicator_type": indicator["type"],
                        "indicator_value": indicator["value"],
                        "malware_family": indicator["malware_family"],
                        "confidence": indicator["confidence"],
                        "first_seen": indicator["first_seen"],
                        "affected_asset": "General",
                        "asset_type": "Network",
                        "description": indicator["description"],
                        "severity": self._calculate_malware_severity(indicator, None)
                    }
                    correlated_threats.append(threat)
            
            self.logger.info(f"Correlated {len(correlated_threats)} malware indicators with assets")
            
        except Exception as e:
            self.logger.error(f"Error correlating malware with assets: {e}")
            
        return correlated_threats
    
    def _find_affected_assets(self, cve: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find assets affected by a CVE"""
        affected_assets = []
        
        # Check servers
        for server in self.assets.get("servers", []):
            for software in server.get("software", []):
                if self._software_matches_cve(software["name"], cve["affected_software"]):
                    affected_assets.append({
                        "name": server["name"],
                        "type": "server",
                        "ip": server["ip"],
                        "software": software
                    })
        
        # Check applications
        for app in self.assets.get("applications", []):
            if self._software_matches_cve(app["name"], cve["affected_software"]) or \
               self._software_matches_cve(app.get("framework", ""), cve["affected_software"]):
                affected_assets.append({
                    "name": app["name"],
                    "type": "application",
                    "software": {"name": app["name"], "version": app["version"]}
                })
        
        return affected_assets
    
    def _find_assets_by_ip(self, ip: str) -> List[Dict[str, Any]]:
        """Find assets by IP address"""
        matching_assets = []
        
        for server in self.assets.get("servers", []):
            if server.get("ip") == ip:
                matching_assets.append({
                    "name": server["name"],
                    "type": "server",
                    "ip": server["ip"]
                })
        
        return matching_assets
    
    def _software_matches_cve(self, software_name: str, affected_software: List[str]) -> bool:
        """Check if software matches any affected software in CVE"""
        software_name_lower = software_name.lower()
        
        for affected in affected_software:
            affected_lower = affected.lower()
            # Check for exact match or partial match
            if (software_name_lower == affected_lower or 
                affected_lower in software_name_lower or 
                software_name_lower in affected_lower):
                return True
        
        return False
    
    def _calculate_remediation_priority(self, cve: Dict[str, Any], asset: Dict[str, Any]) -> str:
        """Calculate remediation priority based on CVE severity and asset criticality"""
        base_priority = cve["severity"]
        
        # Boost priority for critical assets (servers are more critical than applications)
        if asset["type"] == "server":
            if base_priority == "HIGH":
                return "CRITICAL"
            elif base_priority == "MEDIUM":
                return "HIGH"
        
        return base_priority
    
    def _calculate_malware_severity(self, indicator: Dict[str, Any], asset: Dict[str, Any] = None) -> str:
        """Calculate severity for malware indicators"""
        confidence = indicator.get("confidence", 50)
        malware_family = indicator.get("malware_family", "").lower()
        
        # High confidence and dangerous malware families get higher severity
        if confidence >= 90:
            if any(family in malware_family for family in ["wannacry", "emotet", "trickbot", "ryuk"]):
                return "CRITICAL"
            else:
                return "HIGH"
        elif confidence >= 70:
            return "MEDIUM"
        else:
            return "LOW"
    
    def generate_vulnerability_report(self, correlated_vulns: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate a comprehensive vulnerability report"""
        report = {
            "total_vulnerabilities": len(correlated_vulns),
            "severity_breakdown": {},
            "affected_assets": set(),
            "critical_vulnerabilities": [],
            "high_vulnerabilities": [],
            "recommendations": []
        }
        
        for vuln in correlated_vulns:
            # Count by severity
            severity = vuln["severity"]
            report["severity_breakdown"][severity] = report["severity_breakdown"].get(severity, 0) + 1
            
            # Track affected assets
            report["affected_assets"].add(vuln["affected_asset"])
            
            # Separate critical and high vulnerabilities
            if severity == "CRITICAL":
                report["critical_vulnerabilities"].append(vuln)
            elif severity == "HIGH":
                report["high_vulnerabilities"].append(vuln)
        
        # Convert set to list for JSON serialization
        report["affected_assets"] = list(report["affected_assets"])
        
        # Generate recommendations
        if report["critical_vulnerabilities"]:
            report["recommendations"].append("Immediate patching required for critical vulnerabilities")
        
        if report["high_vulnerabilities"]:
            report["recommendations"].append("Plan patching for high vulnerabilities within 7 days")
        
        if len(report["affected_assets"]) > 0:
            report["recommendations"].append(f"Monitor {len(report['affected_assets'])} affected assets closely")
        
        return report
